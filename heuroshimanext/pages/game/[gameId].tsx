import type { NextPage } from 'next'
import dynamic from "next/dynamic"
import Head from 'next/head'
import Image from 'next/image'
import { useContext, useEffect, useState } from 'react'
import styles from '../../styles/Game.module.css'
import {response, color, playerInterface, TileInterface, TileBuild} from "../../common"
import { io, Socket } from 'socket.io-client'
import { PlayerContext, ConnectionContext, unwrap, Config } from '../../components/Contexts'
import GUI from "../../components/Game/GUI"
import { useSocket } from '../../components/Connection'
import { GetServerSideProps } from 'next'

const Game = dynamic(() => import("../../components/Game/Game"), {
  ssr: false,
  loading: () => <div className={styles.loadingStyle}>LOADING</div>
})

export const getServerSideProps: GetServerSideProps = async (context) => {
  return {props: {gameId: context?.params?.gameId}}
}

const G: NextPage<{gameId: number}> = ({gameId}) => {
  const [selected, setSelected]=useState<TileInterface | null>(null)
  const [player, setPlayer] = useState<playerInterface | null>(null)
  const [config, setConfig] = useState<Config>({selectMode: 0})
  const [players, setPlayers] = useState<playerInterface[]>([])
  const connection = useSocket(`ws://heuroshimanex.ddns.net:8000/game`)
  useEffect(() => {
    const onConnect = () => console.log("connected!")

    if(connection) {
      connection.on("connect", onConnect)
      connection.on("broad:player_list", setPlayers)
      connection.on("broad:sync_players", setPlayers)
      connection.emit("req:subscribe", gameId, (d: any) => {
        console.log("req:subscribe", d)
      })
      refreshPlayerList()
    }
    return () => {
      connection?.off("connect", onConnect)
      connection?.off("broad:player_list", setPlayers)
      connection?.off("broad:sync_players", setPlayers)
    }
  }, [connection])
  const handlePlayerList = (response: response<playerInterface[]>) => {
    const data = unwrap(response)
    data && setPlayers(data)
    if(!players.map(p => p.id).includes(player?.id || "")) {
      setPlayer(null)
    }
  }
  const refreshPlayerList = () => {
    connection && connection.emit("sync_players", (d: response<playerInterface[]>) => handlePlayerList(d))
  }
  const playerContext = {
    thisPlayer: player, 
    config: config,
    setSelectMode:(n: number) => setConfig(v => ({...v, selectMode: n})),
    setPlayer: (p: playerInterface) => setPlayer(p), 
    players: players,
    refreshPlayerList: refreshPlayerList
  }
  return (
    <div className={styles.container}>
      <Head>
        <title>HeuroshimaNext v.0.1</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
        {connection && 
          <Game 
            connection={connection} 
            pickHex={(v: TileInterface | null) => setSelected(v)} 
            playerContext={playerContext!} 
          />
        }
        <ConnectionContext.Provider value={connection}>
          <PlayerContext.Provider value={playerContext!}>
            <GUI selectedTile={selected} />
          </PlayerContext.Provider>
        </ConnectionContext.Provider>
    </div>
  )
}

/*
  TODO:
  talia kart
  - lista graczy
        -> kółko z kolorem gracza
        -> zaznaczenie naszej nazwy
    Next Targets:
      - Tury
        -> gracz turowy może klikać, nikt inny (done)
        -. gracz turowy jest zaznaczony jakoś
        -> Turn counter jest widoczny
      - Guziki roziwjają Menu z większą ilością wyborów (3 różne jednostki armii, itp.)
      - jakieś zasoby dla gracza aby był limit postawień rzeczy
      - dalsza logika
      - przeczytać wreszcie zasady gry XD

*/

export default G